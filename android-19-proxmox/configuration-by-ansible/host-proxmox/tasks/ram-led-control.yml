---
# RAM LED Control Tasks - Kingston Fury Beast DDR5 modules
#
# This task file provides direct I2C control of Kingston Fury Beast DDR5 RAM RGB LEDs
# using i2c-tools for static color control.
#
# Dependencies:
# - i2c-tools package (provides i2cset, i2cdetect, i2cget)
# - i2c-dev kernel module loaded
# - AMD FCH SMBus Controller (i2c-1 bus)
#
# Variables:
# - ram_lights_state: "on" or "off"
# - ram_lights_action: "status" to check current state (optional)
# - ram_lights_enabled: boolean to enable/disable this feature
# - ram_lights_color: RGB color (default: "00FFFF" for cyan)
# - ram_lights_brightness: 0x00-0x63 (default: 0x32 = 50%)
#
# Hardware:
# - Kingston Fury Beast DDR5 RAM (2 sticks at I2C addresses 0x61, 0x63)
# - SMBus: i2c-1 (AMD FCH SMBus Controller)

# ============================================================================
# Dependency Check
# ============================================================================

- name: Check if i2c-tools is installed
  command: which i2cset
  register: i2ctools_check
  failed_when: false
  changed_when: false
  tags:
    - ram
    - dependency

- name: Fail gracefully if i2c-tools is not installed
  fail:
    msg: |
      âŒ ERROR: i2c-tools is not installed on this system.

      RAM LED control requires i2c-tools to communicate with Kingston Fury DDR5 RAM via I2C/SMBus.

      ğŸ“‹ To fix this issue:
      Run: apt install i2c-tools -y

      â„¹ï¸  Note: i2c-tools provides direct hardware access to RAM RGB controllers.
  when: i2ctools_check.rc != 0
  tags:
    - ram
    - dependency

- name: Ensure i2c-dev kernel module is loaded
  community.general.modprobe:
    name: i2c-dev
    state: present
  become: true
  tags:
    - ram
    - dependency

# ============================================================================
# RAM LED Control Operations (I2C Direct Access)
# ============================================================================

- name: Turn RAM LEDs off (both sticks via I2C)
  shell: |
    # First RAM stick (0x61)
    i2cset -y 1 0x61 0x08 0x53 && sleep 0.02 && \
    i2cset -y 1 0x61 0x09 0x00 && sleep 0.02 && \
    i2cset -y 1 0x61 0x31 0x00 && sleep 0.02 && \
    i2cset -y 1 0x61 0x32 0x00 && sleep 0.02 && \
    i2cset -y 1 0x61 0x33 0x00 && sleep 0.02 && \
    i2cset -y 1 0x61 0x20 0x00 && sleep 0.02 && \
    i2cset -y 1 0x61 0x08 0x44 && \
    # Second RAM stick (0x63)
    i2cset -y 1 0x63 0x08 0x53 && sleep 0.02 && \
    i2cset -y 1 0x63 0x09 0x00 && sleep 0.02 && \
    i2cset -y 1 0x63 0x31 0x00 && sleep 0.02 && \
    i2cset -y 1 0x63 0x32 0x00 && sleep 0.02 && \
    i2cset -y 1 0x63 0x33 0x00 && sleep 0.02 && \
    i2cset -y 1 0x63 0x20 0x00 && sleep 0.02 && \
    i2cset -y 1 0x63 0x08 0x44
  when:
    - ram_lights_state == "off"
    - ram_lights_action is not defined or ram_lights_action != 'status'
  changed_when: false
  tags:
    - ram
    - control

- name: Turn RAM LEDs on (both sticks via I2C - static color)
  shell: |
    # First RAM stick (0x61)
    i2cset -y 1 0x61 0x08 0x53 && sleep 0.02 && \
    i2cset -y 1 0x61 0x09 0x00 && sleep 0.02 && \
    i2cset -y 1 0x61 0x31 0x{{ ram_lights_color[0:2] }} && sleep 0.02 && \
    i2cset -y 1 0x61 0x32 0x{{ ram_lights_color[2:4] }} && sleep 0.02 && \
    i2cset -y 1 0x61 0x33 0x{{ ram_lights_color[4:6] }} && sleep 0.02 && \
    i2cset -y 1 0x61 0x20 {{ ram_lights_brightness }} && sleep 0.02 && \
    i2cset -y 1 0x61 0x08 0x44 && \
    # Second RAM stick (0x63)
    i2cset -y 1 0x63 0x08 0x53 && sleep 0.02 && \
    i2cset -y 1 0x63 0x09 0x00 && sleep 0.02 && \
    i2cset -y 1 0x63 0x31 0x{{ ram_lights_color[0:2] }} && sleep 0.02 && \
    i2cset -y 1 0x63 0x32 0x{{ ram_lights_color[2:4] }} && sleep 0.02 && \
    i2cset -y 1 0x63 0x33 0x{{ ram_lights_color[4:6] }} && sleep 0.02 && \
    i2cset -y 1 0x63 0x20 {{ ram_lights_brightness }} && sleep 0.02 && \
    i2cset -y 1 0x63 0x08 0x44
  when:
    - ram_lights_state == "on"
    - ram_lights_action is not defined or ram_lights_action != 'status'
  changed_when: false
  tags:
    - ram
    - control

- name: Display RAM LED state confirmation
  debug:
    msg: |
      âœ“ RAM LEDs have been set to: {{ ram_lights_state | upper }}

      Affected components:
        - Kingston Fury Beast DDR5 RAM (2 sticks at I2C 0x61, 0x63)

      State: {{ 'Static color #' + ram_lights_color + ' (brightness: ' + ram_lights_brightness + ')' if ram_lights_state == 'on' else 'All RAM LEDs off (black)' }}

      Method: Direct I2C control via i2c-tools

      âš ï¸  Arctic lights: UNCHANGED (controlled separately via liquidctl)
  when:
    - ram_lights_state is defined and ram_lights_state in ['on', 'off']
    - ram_lights_action is not defined or ram_lights_action != 'status'
  tags:
    - ram
    - control

# ============================================================================
# Status Checking Tasks
# ============================================================================

- name: Check if RAM LED control service exists
  stat:
    path: /etc/systemd/system/ram-led-control.service
  register: ram_service_file
  when: ram_lights_action is defined and ram_lights_action == 'status'
  tags:
    - ram
    - status

- name: Get RAM LED control service status
  systemd:
    name: ram-led-control.service
  register: ram_service_status
  failed_when: false
  when:
    - ram_lights_action is defined and ram_lights_action == 'status'
    - ram_service_file.stat.exists
  tags:
    - ram
    - status

- name: Read RAM LED systemd service configuration
  slurp:
    path: /etc/systemd/system/ram-led-control.service
  register: ram_service_config
  when:
    - ram_lights_action is defined and ram_lights_action == 'status'
    - ram_service_file.stat.exists
  tags:
    - ram
    - status

- name: Check if RGB control service exists (for comparison)
  stat:
    path: /etc/systemd/system/rgb-control.service
  register: rgb_service_file
  when: ram_lights_action is defined and ram_lights_action == 'status'
  tags:
    - ram
    - status

- name: Read RGB systemd service configuration (for comparison)
  slurp:
    path: /etc/systemd/system/rgb-control.service
  register: rgb_service_config
  when:
    - ram_lights_action is defined and ram_lights_action == 'status'
    - rgb_service_file.stat.exists
  tags:
    - ram
    - status

- name: Display RAM LED status
  debug:
    msg: |
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      RAM LED STATUS
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      ğŸ“¦ Hardware:
            Kingston HyperX Fury RAM (led4 channel only)

      âš™ï¸  Systemd Service:
      {{ '      âœ“ Service configured and enabled' if ram_service_file.stat.exists else '      âœ— Service not configured' }}
      {{ '      State: ' + ram_service_status.status.ActiveState | default('unknown') if ram_service_file.stat.exists else '' }}

      ğŸ¨ Configured RAM LED State (from service):
      {{ '      ON (rainbow effect)' if ram_service_file.stat.exists and 'rainbow' in (ram_service_config.content | b64decode) else '      OFF (all LEDs black)' if ram_service_file.stat.exists else '      Not configured' }}

      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Arctic Lights Status (for comparison):
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      âš™ï¸  RGB Control Service:
      {{ '      âœ“ Service configured and enabled' if rgb_service_file.stat.exists else '      âœ— Service not configured' }}

      ğŸ¨ Configured Arctic Lights State:
      {{ '      ON (rainbow effect)' if rgb_service_file.stat.exists and 'rainbow' in (rgb_service_config.content | b64decode) else '      OFF (all LEDs black)' if rgb_service_file.stat.exists else '      Not configured' }}
      {{ '      Controls: Arctic fans and CPU cooler (led1-led3)' if rgb_service_file.stat.exists else '' }}

      â„¹ï¸  Note: Actual LED states may differ if changed manually.
          This shows the configured states that persist across reboots.
      â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  when: ram_lights_action is defined and ram_lights_action == 'status'
  tags:
    - ram
    - status

- name: Create systemd service for RAM LED control persistence
  template:
    src: ram-led-control.service.j2
    dest: /etc/systemd/system/ram-led-control.service
    mode: '0644'
  become: true
  when: ram_lights_action is not defined or ram_lights_action != 'status'
  tags:
    - ram
    - persistence

- name: Reload systemd daemon
  systemd:
    daemon_reload: yes
  become: true
  when: ram_lights_action is not defined or ram_lights_action != 'status'
  tags:
    - ram
    - persistence

- name: Enable RAM LED control service for autostart
  systemd:
    name: ram-led-control.service
    enabled: yes
    # Note: We don't use state: started because:
    # 1. The RAM LED state is already set by the liquidctl commands above
    # 2. This is a oneshot service meant for boot-time persistence
    # 3. Starting it here would be redundant
  become: true
  when: ram_lights_action is not defined or ram_lights_action != 'status'
  tags:
    - ram
    - persistence
